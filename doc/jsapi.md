Sparkling JavaScript API
========================

Building
--------
I've successfully built and run the JavaScript API using the Emscripten portable
SDK version 1.13.1. Versions 1.21, 1.22 and incoming, however, seemed not to be
able to run the generated code. Errors popped up for which I could find no
solution after some googling...

General
-------
The Sparkling JS API consists of the `Sparkling` module object and its methods.
You can use the Sparkling API in your JavaScript program by
including the `libspn.js` script file. You can also try the JavaScript
bindings by opening the `libspn.html` file. This is auto-generated by
the Emscripten compiler. Open a JavaScript console here and type
in the sample code (see later below). Profit.

The workflow in JavaScript is similar to the usage of the C API:
 - First you compile a Sparkling source string into a function.
   This is accomplished using **`Sparkling.compile()`**, which returns
   a JavaScript function that wraps the corresponding Sparkling
   program if it succeeds. On error, it returns `undefined`.
   You can call the returned function as any other JavaScript function,
   pass it various arguments and inspect its return value.
 - If a run-time error occurs, the returned function throws an exception,
   of which the text is the error message as returned by **`lastErrorMessage()`**.
 - Should a parser or compiler error occur, an error message is available by
   calling **`Sparkling.lastErrorMessage()`**.
 - The function **`Sparkling.lastErrorLocation()`** returns an object in the
   format `{ line: X, column: Y }` which contains the line and character number
   of the source where the last parser/compiler error occurred.
 - **`Sparkling.lastErrorType()`** returns the type of the last error
   as a string: one of `"OK"`, `"syntax"`, `"semantic"`, `"runtime"`,
   `"generic"` or `"unknown"`.
 - There are facilities for examining, transforming and compiling Sparkling
   Abstract Syntax Trees: **`Sparkling.parse()`** parses a string and returns
   a tree of objects representing its AST. **`Sparkling.parseExpr()`** does
   the same but it expects the string to be an expression, not a top-level
   program.
 - An AST object can be compiled to bytecode using **`Sparkling.compileAST`**,
   which takes an AST as its parameter and returns a JavaScript function,
   which, when called, will execute the compiled bytecode (Sparkling function).

Mapping between Sparkling and JavaScript types:

	nil        ->   undefined or null
	bool       ->   boolean
	number     ->   number
	string     ->   string
	array      ->   Array
	hashmap    ->   Object
	function   ->   function
	userinfo   ->   SparklingUserInfo object

The mapping between the first four types is mostly self-explanatory. If `nil`
is returned from Sparkling code, it will always be converted to `undefined`.
You can, however, pass either `undefined` or `null` to Sparkling from JS --
both values will be translated to `nil`.

Sparkling arrays are returned to JavaScript as an `Array` object. Hashmaps are
converted to a generic `Object` instance that functions as a hash table.

If a Sparkling hashmap contains keys other than numbers or strings, an
exception is thrown.

The inverse mapping is also conceptually simple: a JavaScript `Array` object
is mapped to a Sparkling array, any other object is converted to a hashmap
with string keys.

One thing to note is that the conversion between Sparkling and JavaScript
arrays, hashmaps and objects is quite expensive, so it's best to reduce the
number of repeated conversions. One should do most of their computation in one
language or another, then transfer the results, preferably only once, when the
two runtimes need to exchange data.

Sparkling and JavaScript functions can interoperate without any further effort.
A Sparkling function, when returned to JS-land, is wrapped into a JavaScript
proxy function object, which, when called, converts its arguments and the
return value of the underlying Sparkling function automagically, according to
the conversion rules described above. Similarly, when a JavaScript function is
passed to Sparkling code, it is converted into a proxy function which forwards
its arguments and the original callee's return value, respectively.

The performance note from above applies to functions as well: the conversion
between functions, their arguments and return value is computationally
expensive, so be careful.

User info objects are returned to JavaScript as an opaque object of prototype
`SparklingUserInfo`. When passed back to Sparkling code, these objects are
automatically converted back to the underlying user info object. Currently,
it's only possible to pass user info objects from JavaScript to Sparkling if
the original user info itself was returned from Sparkling code (so JavaScript
code cannot create user info values).

Other functions
---------------
There are more public API functions in the `Sparkling` module:

 - `compileExpr()` works similarly to `compile()`, but it treats the source
   text as an expression, not as a top-level program nor a statement.
 - `backtrace()` returns an array of strings that contain the names of the
   functions on the call stack at the last runtime error.
 - `getGlobal(name)` returns the Sparkling global value with name `name`,
   or `undefined` if it was not found.
 - `setGlobal(name, value)` sets the global named `name` to value `value`.
 - `freeAll()` frees the result of all function calls, conversions between
   Sparkling and JavaScript code and other operations. This is useful when
   you want to free up some memory after a lot of interoperation between
   Sparkling and JavaScript. Calling this function invalidates all values
   and objects that you created so far, so they must not be used anymore
   (i. e., you have to proceed as if you reloaded the page.) Even if a
   value still seems to be accessible, it may (and usually does) hold a
   now-invalid reference to something, thanks to the indexing system the API
   internally uses for converting between Sparkling and JavaScript values.
 - `reset()` resets the interpreter: it cleans all globals and sets up a
   completely new execution context. Invalidates indices in the same manner
   `freeAll()` does.

Usage example:
--------------
Type the following lines into a JavaScript console on `libspn.html`, or open a
Node.JS / JavaScriptCode / SpiderMonkey / etc. shell and import `libspn.js`:

    > var fn = Sparkling.compile('return "Hello, " .. $[0] .. "!";');
    undefined
    > var greetMe = fn("H2CO3");
    undefined
    > greetMe
    "Hello, H2CO3!"
    > var acc = Sparkling.compileExpr('$[0] + $[1]');
    undefined
    > [1, 2, 3, 4, 5].reduce(acc, 0)
    15
    > Sparkling.compile('return { "foo": "bar", "qux": 1337 };')();
    Object
      > foo: "bar"
      > qux: 1337
